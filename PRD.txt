FocusKey Implementation PlanOverview of App Goals and User ExperienceFocusKey is a productivity app designed to reduce distractions from social media and other apps by leveraging Apple’s Screen Time APIs. The goal is to let users enter a focused state (for work, study, sleep, etc.) during which selected distracting apps and websites are temporarily blocked or limited. The key differentiator is a physical NFC card or stand that acts as a trigger: when the user taps their iPhone on the FocusKey card (or places it on the stand), the app will activate a focus session and immediately apply restrictions to the user’s device. Tapping the card again (or another predefined action) can deactivate the session or initiate a short break, depending on user settings.User Experience Summary: The user configures which apps/websites to block (or allow) for different scenarios (e.g. Work, Study, Sleep presets) within the app. To start focusing, they simply tap the NFC card – this launches FocusKey via a Universal Link and locks distracting apps using Screen Time API controls. While a session is active, attempts to open blocked apps will show a Screen Time “shield” overlay (the same interface iOS uses for app limits) preventing access. The user can optionally be allowed “breaks” – short intervals when the restrictions are lifted – according to a quota (e.g. 5 minutes per hour). The app provides feedback during the session (e.g. a timer or Live Activity on the lock screen) to show focus progress. When the focus session ends (either at user’s request or at a scheduled time), all apps are unlocked again and the session is logged for the user to review. Throughout this process, user privacy is respected – all blocking is done on-device via Apple’s APIs, and usage data is kept locally (unless the user opts into a cloud sync). The overall experience is meant to be seamless and motivating: the physical NFC trigger adds a ritualistic element to starting focus time, and the app’s interface will reinforce the user’s commitment to staying off distracting apps.Architecture and Component BreakdownFocusKey Architecture: The FocusKey system consists of an iOS app (SwiftUI) that interacts with Apple’s Screen Time frameworks, plus optional extensions and services. The architecture diagram above illustrates how the FocusKey appreceives triggers (from an NFC tag via Universal Link or a schedule) and then uses Screen Time APIs to impose or lift restrictions. Major components include the SwiftUI client app (UI and logic), Apple’s Screen Time API frameworks (FamilyControls, ManagedSettings, DeviceActivity) for managing restrictions, a possible DeviceActivityMonitor extension for background enforcement, local storage for configuration and session logs, and an optional cloud backend for syncing data. The design cleanly separates the concerns of UI, business logic, and system integration, making the app modular and maintainable.Key components and their roles:* FocusKey iOS App (SwiftUI): This is the main app that provides all user interfaces and orchestrates the focus sessions. It is built with SwiftUI (targeting iOS 17+) and follows MVVM architecture. The app includes screens for onboarding & requesting permission, selecting apps/websites to block, choosing presets (Work/Study/Sleep), initiating or scheduling focus sessions, and viewing session stats. The SwiftUI views are backed by ViewModelobjects (ObservableObjects) that handle business logic. The app is responsible for responding to triggers (NFC taps or schedule events) by calling the appropriate services (e.g. a FocusSessionManager) to start or stop blocking.* Screen Time API Integration (FamilyControls, ManagedSettings, DeviceActivity): FocusKey leverages Apple’s Screen Time frameworks to implement the blocking. FamilyControls is used for obtaining user authorization and presenting the FamilyActivityPicker UI so the user can select which apps/categories/websites to restrictmedium.com. ManagedSettings provides the enforcement mechanism (the “shield” that actually blocks launches of selected apps and sites)medium.com. DeviceActivity is used to schedule and monitor the timing of restrictionsmedium.com. These frameworks work together: FamilyControls asks the user what to block, ManagedSettings sets up the rules to block those things, and DeviceActivity tells the system when to enforce the rulesmedium.com. In the FocusKey app, a FocusSessionManager (or similar service class) will coordinate these APIs – for example, applying a ManagedSettings shield configuration for the chosen apps, and using DeviceActivity to turn that configuration on or off at the appropriate times.* NFC Trigger via Universal Link: The physical NFC card or stand contains an NDEF message with a URL that uses a domain associated with FocusKey. When the user taps their iPhone on the tag, the device detects the NFC tag in the background and sees the URL. Because it’s a registered Universal Link for our app, iOS will prompt to open FocusKey (even from the lock screen)developer.apple.com. In practice, the NFC tag’s URL might be something like https://focuskey.app/start (our app’s domain). We will set up an Associated Domain so that this URL routes into the app. The OS will show a notification for the tag; tapping the notification launches FocusKey and delivers the URL to the app for handlingdeveloper.apple.com. This mechanism does not require using CoreNFC at runtime, so it works passively on devices iPhone Xs or later (which support background tag reading). For older iPhones that don’t support background NFC reading, we may consider a fallback (like a manual “Start” button in the app) since CoreNFC active scanning is not in scope for v1. The Universal Link route will indicate the action (e.g. “start focus session”); the app will parse the incoming URL and trigger the focus mode accordingly. The same NFC tag could potentially also be used to end a session or initiate a break if the app is already in a focus state – see Lock/Unlock Behavior below for details on handling repeated taps.* DeviceActivity Monitor Extension (background enforcement): (Optional, for scheduled sessions and advanced use cases). Apple’s DeviceActivity framework can utilize an app extension (of type com.apple.deviceactivity-monitor) to run in the background at scheduled times or in response to usage events. For FocusKey, if we offer scheduled focus sessions (e.g. automatically every night at 10pm) or need to respond when a user exceeds a break time, a DeviceActivityMonitor extension will be used. This extension runs separately from the main app and can toggle the ManagedSettings restrictions without the app being open. It will share data with the app via an App Group container. For example, the extension can be configured to listen for the start and end of a scheduled focus interval and then apply or remove the shield accordingly. Notably, when using an extension, an App Group is required so that the extension knows which apps to block (since it needs access to the FamilyActivitySelection or rule set defined in the main app)developer.apple.com. In v1, we can implement the simplest case of schedule (and possibly rely on the main app for on-demand sessions), but an extension ensures focus sessions start/end even if the app isn’t foregrounded.* Local Data Storage (App Group and Database): FocusKey will store user preferences and session logs locally. This includes the set of blocked apps/websites (the FamilyActivitySelection), the definitions of any presets or schedules, and the history of focus sessions (start/end times, duration, breaks taken, etc.). We will use App Group storage so that the data is accessible from the main app, widgets/Live Activities, or extensions consistently. For the data model, we have a few options:o SwiftData or Core Data: Since iOS 17 introduced SwiftData (a new persistence framework), we can use it or Core Data to store objects like FocusProfile (preset configurations) and FocusSession (logs). This structured storage makes it easy to query past sessions or update presets. The Medium guide suggests using SwiftData for storing blocking configurations (profiles) and session recordsmedium.com. We can follow that approach to persist data in the app sandbox (within an App Group container).o SQLite or File storage: Alternatively, a lightweight approach is to encode selections and logs to JSON or use a SQLite DB. However, SwiftData/CoreData will handle serialization and querying nicely for us, so it’s preferred for a production app.o App Group UserDefaults: Small pieces of data (like a flag indicating an active session or the current profile in use) can be stored in UserDefaults with an App Group suite. This can be useful for quick checks (e.g. the extension can read a boolean “focusActive” or current session ID from the App Group defaults).* Optional Cloud Backend (Supabase or iCloud): While FocusKey’s core functionality is local (and fully usable offline), we consider a backend for features like syncing across devices or backup of settings. Supabase (an open-source Firebase alternative) could be integrated to store user profiles and session stats in the cloud. For example, if a user has an iPhone and iPad, a cloud sync would allow them to share the same focus presets and see unified statistics. In v1, this is optional – the plan is to implement local storage first and ensure privacy. If we add Supabase, the architecture would include a network layer to upload/download data and user authentication (perhaps via Sign in with Apple or an email login). We would then have to handle data merging and offline access. Another simpler path for Apple-centric users is to use CloudKit (iCloud) to sync data privately without running our own backend. We will weigh App Group + CloudKit vs. using a third-party backend. For the initial release, local-only storage is safer to avoid any complexity around user accounts and to keep user data private. The design will, however, keep the data layer modular so we can introduce syncing later if needed.In summary, the architecture is modular and adheres to best practices: the UI layer (SwiftUI Views) is kept separate from the control layer (ViewModels and services like FocusSessionManager), which in turn interfaces with the system frameworks (Screen Time APIs) and data layer (storage and backend). This separation (illustrated by the strategy of profiles and strategies mentioned above) makes it easy to extend FocusKey with new triggers or policies without rewriting core logicmedium.com. For example, we could introduce a “Manual Start” button or an Apple Watch trigger in the future by adding a new Strategy, while reusing the same blocking mechanism.Screen Time API IntegrationImplementing FocusKey’s core functionality requires a deep integration with Apple’s Screen Time API frameworks: FamilyControls, ManagedSettings, and DeviceActivity. This section outlines how we will use each of these, along with the user flows of granting permission, selecting content to block, and controlling when blocks are active. We also describe how FocusKey will handle presets and the lock/unlock (break) behavior using these APIs.Authorization Flow (Screen Time Permission)Because FocusKey needs to enforce app restrictions, it must first obtain the proper entitlement and authorization from Apple and the user:* Developer Entitlement: The app requires the com.apple.developer.family-controls entitlement to use Screen Time APIsmedium.com. This is a privileged entitlement that must be requested from Apple during development (we’ll apply through the Apple Developer portal, explaining the app’s purpose is to help users focus by limiting apps). We need this entitlement enabled for the main app and any extension targets that use the Screen Time frameworks (for example, a DeviceActivity monitor extension)medium.com. Without this entitlement, any API calls to FamilyControls/ManagedSettings will simply fail or no-op. We will ensure the provisioning profiles for Debug, TestFlight, and App Store builds all include the entitlement before release.* User Authorization Prompt: Once the entitlement is in place, the app must ask the user for permission at runtime to enable Screen Time management. We will use FamilyControls.AuthorizationCenter to request authorization. On first launch (or whenever the user tries to set up a focus profile), FocusKey will call:swiftCopyEdittry await AuthorizationCenter.shared.requestAuthorization(for: .individual)The .individual option is used since the app is managing the current device for the user themselves (not a child’s device in a Family Sharing context)crunchybagel.com. This will trigger an Apple-provided consent dialog informing the user that FocusKey can monitor and limit app usage. We’ll wrap this call in a Swift concurrency Task and handle errors (e.g. if the user denies access). After this call, we can check AuthorizationCenter.shared.authorizationStatus to confirm we have .approvedstatusmedium.commedium.com. If the status is denied or restricted, the app will need to gracefully handle it (e.g. show an alert that Screen Time permission is required and possibly guide them to Settings > Screen Time to enable it).* Authorization UX: We will integrate this flow into onboarding. For example, the first screen after launch can explain why FocusKey needs Screen Time access (“FocusKey uses Apple’s Screen Time features to block distractions. You’ll be asked to allow this...” for transparency). Then a “Enable FocusKey” button will call the requestAuthorization. If granted, we proceed to the setup of presets. If denied, we show instructions or a fallback mode (the app can still function as a timer without blocking apps, but with reduced effectiveness). In testing, we will verify the flow – note that the authorization prompt only shows once; if the user denies, subsequent calls won’t show a prompt and the user must manually change it. So we’ll make that first ask count by clearly explaining the benefit.App & Website Selection (FamilyControls)After permission is granted, users will select which apps, app categories, and websites they want FocusKey to block during focus sessions. We will utilize the FamilyControls UI components to make this selection user-friendly and privacy-preserving:* FamilyActivityPicker: Apple provides a picker view that automatically lists apps and website categories in a structured way, abstracting the details of identifiers. In SwiftUI, we can present it via a modifier .familyActivityPicker(...) which pops up a modal list of apps/categories for the usercrunchybagel.comcrunchybagel.com. We will add a screen in our app’s settings or preset configuration that includes a button like “Select Apps to Block”. Tapping this will toggle a Boolean state (isPickerPresented = true) and attach the .familyActivityPicker(isPresented:$isPickerPresented, selection:$activitySelection) to our view. The FamilyActivityPicker UI is provided by the system – it shows all installed apps and allows search, and it groups apps by categories (Social, Games, etc.). The user can select individual apps (e.g. TikTok, Instagram), entire categories (“Social Networking”), and even specific websites. The outcome of the picker is a FamilyActivitySelection object, which contains three sets of opaque tokens: applicationTokens, categoryTokens, and webDomainTokens corresponding to the user’s picksmedium.com.* Storing Selection: We will store the resulting FamilyActivitySelection for each focus profile. For example, if the user configures a “Work” preset, they might select a bunch of social media apps and entertainment websites to block. That selection is saved (likely encoded and stored in our database or UserDefaults). We’ll likely create a model object like FocusProfile that has a name (“Work”), maybe an icon, and a stored FamilyActivitySelection. (Note: FamilyActivitySelection is Codable, as shown in Apple’s examples, so we can encode it to Data for persistencecrunchybagel.comcrunchybagel.com.) Each profile can thus have its own list of blocked items.* Presets for Work/Study/Sleep: By default, we can ship the app with three example profiles: Work, Study, and Sleep. These presets will have suggested blocking rules that the user can customize. For instance:o Work: Blocks social media, news, and games, but allows productivity and communication apps.o Study: Blocks social media, games, and maybe messaging apps (to avoid chat distractions), possibly allows educational sites.o Sleep: Blocks all apps except maybe phone calls or meditation apps; could also block blue-light intensive apps in evening.We will implement these presets as pre-defined FocusProfile entries that appear on first launch. The user can select a preset and tweak it (e.g. add another app to block). The presets may also come with default schedules (Sleep might suggest 11pm-7am every day). The app will provide an intuitive UI to toggle these presets on/off or edit them. Internally, presets are handled the same way as any profile: they each have a FamilyActivitySelectionand optional schedule.* Categories vs Specific Apps: One powerful feature of FamilyControls is that it supports categories (like .social, .games). If a user selects a category token, that means all current and future apps in that category will be subject to blockingmedium.com. We will expose this to the user via the picker – for example, selecting “Social Networking” category ensures new social apps downloaded later are automatically included. Our ManagedSettings logic (coming up) will account for category tokens appropriately. We should document for QA that category blocking has precedence over individual allowances (Apple’s forums note that if you block a whole category, you can’t exclude one app from it easily without separate logic)stackoverflow.com. In v1, simplest approach: if a category is selected, we block it entirely; if the user wants to allow a specific app in that category, they shouldn’t select the whole category in the first place.* Web Domain Selection: The FamilyActivityPicker also allows specifying website domains to block. We will allow the user to input or select common distracting websites (e.g. facebook.com, youtube.com). The selected domains go into webDomainTokens in FamilyActivitySelection. When enforced, any attempt to visit those in Safari (or perhaps any web view) will trigger the Screen Time block. We’ll clarify to users that this only works in Safari and iOS browsers (which use WebKit) – it won’t block content inside native apps (e.g. you block youtube.com but the YouTube app is separate, so you’d block the app itself). For v1, focusing on app blocking might suffice, but including web is a nice extra.Applying Restrictions with ManagedSettings (Locking Apps)Once we have a set of apps/websites to block, FocusKey will use the ManagedSettings framework to enforce those restrictions. ManagedSettings provides a ManagedSettingsStore through which we specify a “shield” configuration. The shield is what causes the system to block launching an app or loading a website and to show the Screen Time overlay UI.* ManagedSettingsStore Setup: We will create a ManagedSettingsStore with a unique store name (e.g. "FocusKeyRestrictions"). This store name ties together our app and the DeviceActivity schedule (the DeviceActivityCenter looks for a store with the same name to enforce)medium.com. The store has various properties (like .shield.applications, .shield.webDomains) that we can set. When we want to block certain apps, we will assign their tokens to these properties. For example, to block a specific set of apps, we do:swiftCopyEditstore.shield.applications = selection.applicationTokens.isEmpty ? nil : selection.applicationTokensstore.shield.applicationCategories = selection.categoryTokens.isEmpty ? nil : .specific(selection.categoryTokens)store.shield.webDomains = selection.webDomainTokens.isEmpty ? nil : selection.webDomainTokens(This pseudocode is based on Apple’s examplemedium.com.) Essentially, we take the tokens the user selected and tell ManagedSettings to prepare to shield those apps (and categories and domains). If a list is empty, we set it to nilmeaning no restriction of that type.* Activating the Shield: Simply configuring the store does not immediately block the apps until DeviceActivity starts monitoring (see next section). It’s more like defining the rule set. However, there is a scenario where we might want to apply the shield instantly without a schedule – Apple’s API might allow using ManagedSettings directly for immediate blocking. In practice, though, Apple’s design is that you set up ManagedSettings rules and then tie them to a schedule (which can be “always on”). To simplify v1, we will treat “activating focus mode now” as starting a DeviceActivity monitoring session that covers “now until turned off” (rather than trying to manually enforce without DeviceActivity). This ensures the blocking will persist even if the app is closed, until we call stop.* Shield UI and Behavior: When the shield is active on an app, the user sees the standard Screen Time blocked interface if they try to open it. By default, it says something like “Time Limit – You’ve reached your limit on [App]” with an option to ignore for 1 minute or ignore for the day (if it were a normal Screen Time limit). However, since we are using the API for a custom purpose, we can customize the text that appears via ManagedSettings configurations or a Shield Action Extension. Apple provides the ability to customize the shield appearance (like the title/reason) and to handle actions (like if the user taps “Ignore Limit” we could intercept that). For FocusKey, we might configure the shield message to say “Blocked by FocusKey” so it’s clear why it’s blocked. If possible, we will remove the “Ignore for day” option or handle it such that it doesn’t permanently bypass our block (this might require a Shield Action extension to override the default behavior). For v1, we might accept the default shield which does allow the user to bypass after acknowledging – since this is for self-discipline, if a user is determined to bypass, they can. We will simply record if they bypassed (if the API allows detecting it) to include in their session stats (“you left your focus early”).* Time Limits vs. Full Blocking: ManagedSettings can also enforce time-based limits for apps (like allow 5 minutes then block)medium.com. In our use case, we are not specifically using the per-app time budget – instead, we block outright for the focus duration. Breaks are handled by completely lifting the shield for all apps or none, rather than using per-app timers (which are more for parental control scenarios). However, if we wanted, we could integrate time limits if a user wanted to allow, say, 10 minutes of social media during lunch even in Work mode. That might be beyond v1 scope, but the architecture (ManagedSettings + DeviceActivity) does support granular time limits which we could consider in the future.* Removing Restrictions: When a focus session ends (or a break begins), we will remove the shield by setting those properties back to nil (for apps, categories, websites). Our FocusSessionManager will have a method deactivateRestrictions() that essentially does the inverse of apply: set store.shield.* = nil for each, thereby unblocking everythingmedium.com. This doesn’t revoke the permission or anything, it just clears our rules. Removing restrictions should immediately allow the apps to be opened again (the next time the user tries). We’ll verify in testing that stopping monitoring (DeviceActivity) plus clearing the store indeed lifts the block without needing a device reboot or such.Activating & Scheduling Focus Sessions (DeviceActivity)To control when the ManagedSettings rules are enforced, we use the DeviceActivity framework. This allows both immediate on-demand activation and scheduled (recurring) activation of the restrictions:* Immediate Focus Start (On-Demand): When the user taps the NFC card (or presses a “Start Focus” button in the app), we treat this as the user wanting to begin a focus session right away. Under the hood, we will:1. Ensure the ManagedSettingsStore is configured with the appropriate shield (for the selected profile’s apps).2. Define a DeviceActivitySchedule that effectively covers “now until further notice.” The simplest approach is to use an always-on schedule (24 hours, every day) and start it now, then manually stop it when done. For example, we create a schedule from 00:00 to 23:59 repeating dailymedium.com – this means “if monitoring is on, always enforce during the day.” We then call DeviceActivityCenter.startMonitoring(activityName, during: schedule) to turn on monitoringmedium.com. The activityName is a unique identifier we define (like "FocusKeyActiveSession") and it’s associated with our ManagedSettingsStore by namemedium.com. By starting monitoring, iOS will immediately enforce the shield rules we set earlier on the current devicemedium.com.3. The focus session is now active. Our app can update the UI state to show that the session started (e.g. show a countdown if there’s a predetermined duration, or just an “active” indicator if open-ended). We might also record the start time in our session log.Essentially, starting monitoring is what “locks” the apps, since the system checks our ManagedSettingsStore during the scheduled interval and finds the apps to shield. In code, this looks like:swiftCopyEditlet center = DeviceActivityCenter()try center.startMonitoring(FocusSessionManager.activityName, during: schedule)(with proper error handling). We expect this call to succeed if authorization was granted. If there’s an error, we’ll log it and alert the user.* Focus End (Stopping Session): When the user chooses to end the focus session (or the session’s time runs out if it was time-bound), we will call center.stopMonitoring(activityName) to cease enforcementmedium.com. We will also call our ManagedSettings removal to ensure the shield is cleared. Stopping monitoring immediately lifts the restrictions (or at least within a few seconds). In addition, we’ll finalize the session log (record end time, calculate total focused duration minus any break time) and update the UI accordingly. If the session was open-ended, tapping the card or “End Session” button triggers this. If the session was scheduled to end at a certain time (like Sleep mode until 7:00 AM), the DeviceActivityMonitor extension would receive an intervalDidEnd callback at that time and we’d similarly stop enforcement in the extension.* Scheduled Sessions (Recurring): FocusKey will allow users to set up automatic schedules for focus sessions. For example, a user could schedule “Sleep Focus” from 11:00 PM to 7:00 AM every day. To implement this, we leverage DeviceActivity’s ability to define a repeating schedule:o We create a DeviceActivitySchedule with the desired start and end times (as DateComponents). For 11 PM to 7 AM, that might be intervalStart: DateComponents(hour:23, minute:0) and intervalEnd: DateComponents(hour:7, minute:0) with repeats: true and a specific days-of-week pattern (DeviceActivitySchedule can take an optional parameter for weekdays; if not, we might just call startMonitoring daily).o We then call startMonitoring(activityName, during: schedule) once, and the system will automatically enforce the restrictions every day at 11 PM and lift them at 7 AM. This uses the DeviceActivity monitor extension to receive events. In our extension’s implementation (which runs out-of-process), we’ll override handlers like intervalDidStart(for: activity) and intervalDidEnd(for: activity) to apply or remove the ManagedSettings shield. However, if we named our ManagedSettingsStore the same as the activity, the system might enforce automatically without custom codemedium.com. According to documentation, starting monitoring with a given name causes the system to look for a store with that name and enforce it during the schedule. We will verify if any extension code is needed or if it “just works” by linking the names.o For safety and for any custom logic (like sending a notification “Focus session started” or logging events), we will include the DeviceActivityMonitor extension. This extension can also implement deviceActivityEvents(for:) to get more granular events if needed (like “if user spent X minutes on a specific category, do something”), though that’s not a primary feature for v1.o The app’s UI will expose scheduling in the preset settings. For example, on the Sleep preset, a user can toggle a “Schedule daily” switch and pick start/end times. We’ll store those times and on save, call a scheduling function that configures DeviceActivity. We must also handle the case where a user disables a schedule – in that case, we call stopMonitoring(activityName) for that schedule and possibly remove the extension’s data for it. Only authorized apps can schedule these, so FocusKey will manage only its own schedules.* Multiple Profiles & Overlap: A potential complexity is if a user schedules multiple profiles that could overlap (e.g. Work focus on weekdays at 9-5, Sleep focus daily 11-7). Since DeviceActivity uses activity names to identify different rulesets, we can have separate activity names for each profile’s schedule. The system might allow multiple monitors simultaneously as long as they have distinct names. We’ll need to ensure that overlapping times don’t conflict in unintended ways. Possibly, ManagedSettingsStore name could incorporate the profile name so that each profile has its own shield configuration. If overlaps occur, iOS might apply both (which essentially is fine since both would block their respective apps – the union of blocked apps is blocked). We’ll document and test this scenario. For simplicity, in v1 we might restrict overlapping schedules or ask the user to resolve conflicts (e.g. if Work and Sleep overlap, Sleep might take precedence or we combine the rules).* DeviceActivityMonitor Extension Implementation: In the extension target (likely named something like FocusKeyMonitor), we will subclass DeviceActivityMonitor and implement at least one function, probably intervalDidStart(activity:DeviceActivityName) and intervalDidEnd(...). In these, we ensure the ManagedSettings shield is applied/removed. If we rely on the system’s implicit linking by store name, we might not need to do much in code except perhaps logging. But to be robust, our extension could explicitly set store.shield.applications = ... on start if needed. The extension will have access to the same App Group storage to retrieve the latest FamilyActivitySelection for that profile. This is why we configure App Group: the extension can read a shared file/UserDefaults to get the list of apps to blockdeveloper.apple.com. We will ensure to update that shared data whenever the user updates their selections.* Ending Sessions Early: If a session is scheduled till a certain time but the user wants to end it early (e.g. they woke up at 6am and want to use the phone), FocusKey should allow an override. We’ll have an “End Session” button in the app that is available even for scheduled sessions. Pressing it will call stopMonitoring for that activity (which stops the current interval and presumably calls intervalDidEnd). However, Apple’s framework might then restart it the next day as usual. We should clarify to the user if ending early is one-time or permanently disabling the schedule. Likely, “End Now” would just exit the current session instance but the schedule remains for the future. We will handle that logic accordingly (for example, if user ends a scheduled session, maybe skip the enforcement for the rest of that day).Lock/Unlock Behavior and Break QuotasOne of FocusKey’s important usability aspects is how the lock (focus) and unlock is handled beyond a simple on/off switch. We want to encourage users to stay in the focus session once started, but also provide some flexibility through “breaks” so that the system feels supportive rather than overly rigid.* Session Lock (Activation): When a session is activated (via NFC or manually), the app will clearly indicate that the device is in “Focus Mode.” This could involve:o Changing the app’s theme or showing a prominent timer/countdown.o Possibly enabling a Live Activity on the lock screen (discussed later) showing that FocusKey is active.o Optionally, enabling an iOS system Focus (like Do Not Disturb or a custom Focus mode) to silence notifications, if the user desires. (This is not required, but we could integrate with the Focus Status API to toggle a particular focus mode for fewer notifications).During the session, all apps in the blocked list are effectively locked by the Screen Time shield. If the user tries to tap a blocked app icon, they will see the shield screen. By default, the shield screen has an “Ignore Limit” option which if tapped will ask for the Screen Time passcode (if the user has one set for themselves; if not, it might just allow a short bypass). Since FocusKey is a self-imposed system, the user likely has no Screen Time passcode for themselves (that’s usually for parents). In iOS 17, Apple might allow a bypass if the user confirms, but we as the app don’t get direct callbacks unless we use a Shield Action extension. For v1, we assume the user won’t actively use “ignore for today” because that defeats the purpose (and if they do, that’s on them). In a future update, we could add a custom ShieldAction extension to intercept that and instead route it as a “request break” inside our app.* Session Unlock (Deactivation): Normally, a session ends when the user taps “End Focus” in the app (or scans the NFC tag again, if we decide to treat a second tap as an end command). We need to be careful with using the NFC card for both start and end: a inadvertent tap could end the session early. One approach: require a deliberate action in-app to end, so that the NFC card primarily starts focus, and maybe also pauses it. However, to use the physical metaphor, perhaps tapping the card is like a key: tapping it toggles the state. We can implement it such that:o If no focus session is active, NFC tap => start session.o If a focus session is active, NFC tap => (do not immediately stop; instead open the app to a screen where the user can confirm unlock or take a break).This way, a single NFC tap won’t instantly cancel focus without confirmation. The app could show “Focus session in progress. Do you want to end it or take a short break?” to the user. This additional step prevents accidental deactivation and encourages mindful breaks rather than quitting on impulse.* Break Quota Mechanism: We introduce the concept of “breaks” – temporary unlock periods during a focus session. For example, a user might allow themselves one 5-minute break every hour when they can use their phone normally. This is implemented by pausing the restrictions for a short duration:o The user initiates a break by either pressing a “Take a Break” button in the app or possibly double-tapping the NFC card (if we can differentiate that, though likely easier via the app UI).o When a break starts, FocusKey will stop the DeviceActivity monitoring (or otherwise disable the shield) just like ending the session, but it will also start an internal timer for the break length.o The app can show a countdown for the break (e.g. “Break: 5:00 minutes remaining”). A Live Activity could be very useful here to show time remaining in the break on the Lock Screen so the user knows to wrap up.o When the break time is over, FocusKey will automatically re-activate the focus session by re-starting the DeviceActivity monitoring and reapplying the shield. Because of iOS constraints, automatically reactivating might need the app to be running in background. We can leverage a couple of strategies: if the break is short (<=5 minutes), we might be able to use a BGTask or even just schedule a local notification that when tapped can trigger the resume. More directly, since our app is likely in foreground during a break (user might be using the phone), we can schedule a Swift concurrency Task with a sleep() for break duration and then call startMonitoring again. We have to test if this works if the app is backgrounded. Alternatively, the DeviceActivity schedule approach: we could have defined a schedule that has a built-in break (but the API doesn’t directly support alternating intervals in one schedule easily). So probably manual control is fine.o The break quota means we limit how many breaks or how long in total. For example, in a 2-hour focus session, maybe the user is allowed a maximum of two 5-minute breaks. We’ll keep track: each time they take a break, deduct from their quota. If they try to take another break and none are left, the app will discourage it (perhaps grey out the break button and say no breaks left).o Quota configuration: We can allow the user to configure their allowed breaks in a profile (like Work profile might have 1 break per hour, Sleep might allow no breaks). For simplicity, we could hardcode a sensible default or tie it to session length (e.g. 5 min break per 30 min focus).o While on break, the app will likely have to temporarily store the state that “we are in a break and session will resume soon.” Possibly we treat the break as just part of the session (the session isn’t ended, it’s paused). In the session log, we can record break start/end times to later calculate effective focus time.* Shield During Break: Obviously during break, we remove the shield so the user can access all apps. Technically, we achieve that by calling stopMonitoring and clearing shield. After break, to resume, we reapply shield and call startMonitoring again. The DeviceActivity frameworks might consider stopping and starting frequently as a misuse, but since the entitlement is there, it should function. We should test that calling startMonitoring a second time in short succession works (perhaps using a different DeviceActivityName or reusing the same name). If reusing same name after a stop, it should restart fine. We’ll ensure to catch errors and perhaps add a slight delay if needed.* Live Activity for Ongoing Session (Optional): To improve user awareness, we plan to incorporate a Live Activitywhen a focus session is active. Live Activities (via ActivityKit) let us display a persistent notification on the lock screen and Dynamic Island (on applicable iPhones) with real-time info. For FocusKey:o When a session starts, we can start a Live Activity showing something like “Focus Session: 0:45 remaining” (if a set duration) or an ongoing timer “Focus Session active – Stay focused!” along with perhaps a small icon or progress ring.o We can include actions in the Live Activity. iOS 17 allows up to four buttons in a Live Activity. We might include actions such as “End Now” and “Take Break” directly on the Live Activity for quick access (for example, a student focusing might not want to navigate the app to take a break, they could press a button on the lock screen). These buttons would trigger intents that our app handles – e.g. the “End Now” intent would call the same stop logic, and “Take Break” would initiate the break logic.o Live Activity would need a Widget Extension target to define its UI. We would create FocusKeyActivityAttributes (with properties like sessionId, endTime, or breakRemaining) and update the Live Activity using our app’s state.o We’ll mark the Live Activity as optional because it’s an enhancement; the core focus locking does not depend on it. If time permits, implementing it in v1 would greatly improve UX by reminding the user they are focusing whenever they glance at their phone (which might discourage mindless unlocking).o Implementation detail: enable “Supports Live Activities” in the app’s Signing & Capabilities. No additional entitlement needed unless we wanted push updates (not needed here, as updates are local). We’ll design a simple Live Activity UI: maybe a text like “Focus Mode: Work” with a timer. During a break, the Live Activity could change color or text to indicate “Break time: X:XX left”. This real-time feedback can gently nudge the user when break ends.* Safety and Overrides: We should consider scenarios like emergency or critical tasks. Since FocusKey is user-initiated, we assume they won’t start it when expecting an important call or such. But if something comes up, they can always end the session (no permanent lock-in, we are not bricking the phone). If the user has set a Screen Time passcode for themselves (less likely in self use), then even ending the session might require that passcode because Apple might treat it as a parental control scenario. We’ll mention in user guidance that no Screen Time passcode should be set for yourself if using FocusKey, or else you’ll lock yourself out unless you know the code (which you presumably do, but it’s an extra step).In summary, FocusKey’s lock/unlock behavior uses the Screen Time API to strongly enforce app blocking, but the app’s logic adds a layer of flexibility (breaks with quotas, confirmations on end) to make it user-friendly. This encourages commitment to focus sessions while still acknowledging human needs for short breaks, all under the user’s control.Live Activity Status (Optional)(Optional feature for v1; can be added if time permits)Using a Live Activity, FocusKey can display a persistent status on the Lock Screen and Dynamic Island during an active focus session. This serves both as a reminder and a quick control interface:* Purpose: The Live Activity will show information like the current focus profile (e.g. “Focus: Work”) and time remaining if the session is time-bound (or elapsed time if open-ended). It makes the focus commitment more visible – every time the user glances at their locked phone, they see that they’re in a focus session, which can dissuade casual unlocks. If they do unlock and go to the Home Screen, the Dynamic Island (on iPhone 14 Pro and later) could show a small icon or timer as well.* Design: We will create a Live Activity with, for example, a circular progress indicator or simply a countdown text. It might say “?? Focus 45:00 remaining” at start and count down. If the session is indefinite, it could show elapsed time like “?? Focus in progress: 1h 10m” to encourage longer focus streaks. For break periods, the activity might turn a different color or icon (e.g. orange pause icon) and show “Break: 02:00 left” so the user knows break time is ticking.* Actions: The Live Activity can include quick action buttons such as End and Pause/Resume:o End: If tapped, it will trigger an intent to end the focus session immediately, calling our app to stop monitoring and end the session.o Pause: If tapped during focus, this could initiate a break (if breaks are allowed). Conversely, if tapped during a break, it could serve as Resume to end the break early and re-lock the phone. These intents will call into the FocusSessionManager accordingly.* Implementation: We need to add a Widget extension to the app and use ActivityKit APIs. We define FocusSessionAttributes with relevant content state (like remainingTime or isBreak). When a session starts, in our FocusSessionManager we call:swiftCopyEditif ActivityAuthorizationInfo().areActivitiesEnabled {    let attributes = FocusSessionAttributes(profileName: "Work")    let initialContent = FocusSessionAttributes.ContentState(timeRemaining: sessionLength, isBreak: false)    do {        activity = try Activity.request(attributes: attributes, contentState: initialContent, pushType: nil)    } catch { print("Live Activity failed: \(error)") }}We will update the Live Activity as time counts down (perhaps using a Timer or by scheduling the end if known). If a break starts, we update the content state with isBreak=true and break end time. The UI of the Live Activity is defined in a SwiftUI view in the widget extension, where we format the content state into text/progress.* App Group for Activity: We can share data with the widget via App Group or simply through the Activity content state we push. Likely we can manage via the content state directly as above.* Ending the Activity: When the focus session ends, we call activity?.end(dismissalPolicy: .immediate) to remove it from the lock screen.While not strictly required, the Live Activity aligns with iOS 17+ best practices for long-running processes and improves user engagement (the user stays mindful of their focus session). It’s a nice-to-have that we will implement if resources allow, after the core blocking features are solid.Schedule Integration and Session LoggingBeyond on-demand sessions, FocusKey supports scheduling and keeps a log of sessions for user reflection and debugging.* Scheduling Integration: Users can define scheduled focus sessions as described earlier (e.g. a daily Sleep schedule). This integration means the app will configure DeviceActivity monitors that automatically enforce blocking at set times. In the UI, schedules will likely be managed per preset:o Each preset (Work/Study/Sleep) can have a schedule. We’ll provide a UI to pick days of week and start/end times (similar to setting an alarm or iOS Focus schedule). For example, the user might schedule Work focus Monday–Friday 9:00–17:00.o The app will validate schedules to avoid overlaps or warn the user if two profiles overlap.o On saving, the app registers the schedule via DeviceActivity as described. We need to add the schedule registration likely in an async task because startMonitoring can throw.o If a schedule is active and the user hasn’t opened the app in a while, the DeviceActivityMonitor extension will still enforce it (assuming the app was launched at least once after install to set it up – iOS will keep the extension schedule running in the background).o We will also integrate scheduled sessions with notifications: perhaps 5 minutes before a scheduled focus starts, we could send a notification like “Focus session starting soon” (if the user wants a heads-up). DeviceActivity has a warningTime property for schedule – we can possibly use that so the system gives a warning before enforcementmedium.com. In the Medium example, they didn’t use a warning, but we could experiment with setting warningTime: 5 * 60 (seconds) to trigger a delegate call before the block begins. Then our extension or app could notify the user (“Last chance to wrap up – Work focus will begin and apps will be blocked”). This is optional polish.o After a scheduled session ends, we might notify “Focus session ended” or just let it silently end.* Interaction of Schedule and NFC: The NFC card is primarily for manual triggers. If a scheduled session is about to start but user hasn’t put their phone on the stand, it doesn’t matter – the blocking will start regardless at the time. If they do tap the card outside scheduled times, that starts an unscheduled session. If that overlaps with a scheduled session’s start, we might either treat it as the same or have the scheduled one override. We should handle this logic: one idea is to unify them by always using a single “active session” concept. If a schedule triggers while a manual session is already active (maybe user started early), then nothing new needs to happen except the end time might already be set by schedule; conversely, if user manually started and schedule says it should end later, we might keep it running. We will document such edge cases but they are unlikely for a user to exactly collide.* Logging Focus Sessions: FocusKey will maintain a session log to allow users to review their progress and also to facilitate debugging. Each time a focus session is completed (manually or scheduled), we create a record that includes:o Profile used (Work/Study/Sleep).o Start timestamp and end timestamp.o Duration (end – start minus break time).o Break details: number of breaks taken, total break time, possibly timestamps of breaks.o If the session was ended early or if any bypass was used (if we can detect the user ignored the limit, we would note that).This data will be saved in our local database (e.g. as a FocusSession entity). We’ll expose it in the app’s UI, maybe as a “History” screen or as part of profile stats (“This week you focused for 10 hours, with 3 breaks”). For v1, a simple list of past sessions with date and duration might suffice.* Analytics and Insights: With the session logs, we can compute helpful metrics for the user, like streaks (days in a row they met a focus goal), total time focused, or a “Focus Score.” These are not core to functionality, but enhance the experience and give positive reinforcement. All such analytics can be done on-device using the logged data. This addresses the “local-only analytics” requirement: we don’t send this to a server; it’s purely for the user’s benefit within the app. For example, we might show a chart of focus hours over the past week using SwiftUI Charts (if time permits).* Debug Logging: We will also implement some internal logging especially for QA: logging events like “Requested authorization status = approved”, “Started monitoring at 14:00”, “User took break, stopMonitoring called”, etc., possibly using os_log or print to console. If issues arise (like an app not actually blocking), these logs help pinpoint where the flow failed. We may include a hidden screen in the app (for developers) to view recent log events or the current state of the ManagedSettingsStore for debugging during development.In essence, scheduling broadens FocusKey from a manual tool to an automatic habit-enforcer, and session logging ensures users can reflect on their behavior changes and that the system can be validated and improved over time.Data Storage and Sync ConsiderationsFocusKey’s data consists of user configurations (profiles, schedules, selections) and usage logs. We will carefully choose where and how to store this data, balancing privacy, reliability, and potential sync needs:* On-Device Storage (App Group): All data will be stored on-device by default. We will utilize the App Group container (e.g. group.com.yourteam.FocusKey) for any data that needs sharing between the main app and extensions:o Profiles and Selections: We will store the FamilyActivitySelection tokens for each profile in a persistent store. If using SwiftData/CoreData, we define entities like FocusProfile with attributes (name, color, etc.) and perhaps raw Data or a codable object for the selection tokens. Using SwiftData means we can easily fetch and update this data in SwiftUI.o Session Logs: Stored similarly as FocusSession entities, possibly with attributes for date, duration, etc.o Current State: A few small pieces of state like “current active profile name” or “isSessionActive” flag might be stored in App Group UserDefaults for quick access, especially for the extension or widget. For instance, the extension could read a boolean from UserDefaults in the App Group to confirm which profile to enforce if multiple are defined. (Alternatively, the extension could be coded to enforce all profiles that have schedules, but if multiple active at once, it needs to know combined tokens. Simpler: only one session at a time can be active, so store the active profile ID.)* App Group vs. Standard Container: We’ll use App Group everywhere, even in the main app, to avoid confusion. This way, whether the user is in the main app or an extension, they’re reading/writing the same underlying files. Note that when the app is uninstalled, App Group data is removed as well (unless it’s shared with another app, which we don’t have). If the user reinstalls, they start fresh unless we have cloud sync.* Cloud Sync (Future/Optional): The plan for v1 is not to require the user to create an account. However, we want to keep the door open for optional cloud features:o Supabase: If we integrate Supabase, we would incorporate an authentication mechanism (probably using Magic Links or Apple Sign In to keep it simple). Once authenticated, the app would upload the profiles and session logs to Supabase’s database (likely PostgREST or a similar interface). Supabase could also handle realtime if we needed (not really needed here). This would allow viewing focus stats on multiple devices or maybe a web dashboard in the future.o iCloud: A lighter approach is to use CloudKit. Since this is a single-platform app, iCloud would suffice to sync data between the user’s devices logged into the same Apple ID. We could use NSPersistentCloudKitContainer if using Core Data, or directly use CloudKit APIs for a few records (FocusProfile, FocusSession). The advantage is no account system needed – just toggle on iCloud sync. The disadvantage is less control over data model migrations, but doable.o In either case, privacy remains paramount: we are not sharing this data with third parties except for the user’s own use. If using Supabase or any cloud, we will have a clear privacy policy and perhaps allow the user to opt-in explicitly (maybe as a “backup & sync” feature separate from core functionality).* Why local-first: Keeping everything local aligns with Apple’s privacy guidelines for Screen Time apps – Apple emphasizes empowering users while maintaining privacydeveloper.apple.com. The Screen Time frameworks themselves are privacy-preserving (the FamilyActivityPicker doesn’t tell us the names of apps in the selection, it gives opaque tokens, and certain data like usage habits are not exposed directly to us without user involvement). FocusKey will not collect any sensitive information beyond what is needed to function (which apps to block and when). All of that remains on the user’s device. If we later implement any analytics (like aggregate which apps are most blocked among users), we’d make sure to anonymize and get user consent.* Backup: If we are not implementing cloud sync in v1, users’ data lives only on their phone. We should rely on iCloud Backup or manual export if they want to transfer. As a nicety, we might allow exporting their profile settings (e.g. to a JSON) that they can import on another device. But that’s low priority. Most critical is to ensure if they delete and reinstall the app, they’d have to re-set it up (which might be fine for an initial release).* App Group Security: We’ll mark the App Group with the appropriate security. Only our app and its extensions have access. The data we store (like FamilyActivitySelection) is not human-readable easily (it’s encoded). Still, we might encrypt sensitive pieces if any (though there’s not much beyond maybe the list of apps they block, which is not highly sensitive). We will ensure no other app can access our App Group (they can’t unless they have the same group identifier and signing, which only our app will).* Storage Performance: The amount of data is small (a handful of profiles, maybe dozens of session logs). Core Data/SwiftData can handle this easily. We’ll make sure to batch writes (not do heavy disk writes in the middle of UI updates) – for example, writing a session log at end of session is fine. We’ll also consider background saving if needed.In summary, FocusKey will use App Group local storage for all data in v1, which simplifies development and maximizes privacy. We design the data layer such that adding cloud sync later will be a matter of plugging in a syncing service on top of the local store (for example, implementing a method to upload new sessions to the cloud after they’re saved locally).Modular SwiftUI Structure and Best PracticesWe will structure the FocusKey Xcode project in a modular, scalable way following SwiftUI and MVVM best practicesto ensure the codebase is easy to navigate and extend:* Separation by Feature: We will organize code into folders by feature or domain. For example:o Onboarding/ – Views and view models for the first-run experience and authorization flow.o Profiles/ – Everything related to creating/editing focus profiles (presets). This includes the FamilyActivityPicker view, the model for FocusProfile, and the screens to choose apps or schedule.o Session/ – The focus session runtime views. This might include the view that shows when a session is active (with timer, break button, etc.), and its view model that interacts with FocusSessionManager.o History/ – Views to display past sessions and stats.o LiveActivity/ – If implementing, the widget extension code for the Live Activity UI.Grouping by feature keeps all related components together, which is helpful as the app grows.* MVVM Pattern: SwiftUI encourages MVVM:o We will create ViewModel classes (as ObservableObject) for each major view or feature. For example, FocusProfilesViewModel to manage the list of profiles, SessionViewModel to manage an ongoing session state, etc. These view models will contain business logic and state, and the SwiftUI Views will simply observe them via @StateObject or @ObservedObject.o The ViewModels will use service classes for specific tasks (to avoid bloated view models). For instance, a ScreenTimeService (or FocusSessionManager) class will handle the direct calls to FamilyControls, ManagedSettings, DeviceActivity. The view model can call focusManager.startSession(profile) which in turn does the API calls, then the view model updates its @Published properties (like isFocusActive = true).o Models: We will define model structs or classes for our data: e.g. FocusProfile, FocusSessionLog. These might be plain Swift structs or Core Data/SwiftData managed objects. They represent data but have minimal logic. Any logic like “calculate total focus time this week” either goes in a computed property in a view model or a separate AnalyticsService.* Services and Managers: To keep code modular:o FocusSessionManager (ScreenTimeService): A singleton or environment object that encapsulates all interactions with the Screen Time APIs. This manager would have methods like requestAuthorization(), applyRestrictions(selection), startMonitoring(schedule), stopMonitoring(), etc – essentially the code we outlined earlier but wrapped nicely. This separation means our view models don’t need to know the details of ManagedSettings; they just call focusManager.beginFocus(profile). The manager can also handle keeping track of current session, break timer logic, etc., which centralizes that logic.o NFC/UniversalLink Handler: Although iOS will launch us with a URL, we might have a coordinator to interpret that. In SwiftUI App lifecycle, we can use @Environment(\.openURL) or the onContinueUserActivity modifier on the Scene. We’ll implement something in our App struct (FocusKeyApp: App) to handle the universal link. This could simply call a method in a URLRoutingService. For cleanliness, we might have a small FocusKeyURLHandler that parses the URL (like focuskey.app://start?profile=Work) and then invokes FocusSessionManager accordingly.o DataService: If using Core Data, we’ll have a PersistenceController to manage the context. If using SwiftData, much is handled by the framework with @Model objects and so on. We will however have repository-like functions (e.g., ProfileStore for saving/loading profiles, SessionLogStore for logs). In small scale, the view models might directly use @Query (if SwiftData) or fetch requests, but a service layer is good for testability.o Settings/Permissions Service: Optionally, a service to handle checking if the Screen Time authorization is granted, and possibly if the user has any Screen Time passcode that might interfere (there’s no API to check passcode, but we might infer).* Modularity and Extensions: The architecture from the Medium article suggests using a Strategy pattern for blocking strategiesmedium.com. We can adopt a similar approach: define a BlockingStrategy protocol that has methods like activate() and deactivate(). Then implement concrete strategies:o ManualBlockingStrategy – triggers on immediate user action (NFC/manual) and likely just calls FocusSessionManager directly.o ScheduledBlockingStrategy – triggers based on time schedule (this could interface with DeviceActivity extension).o In the future, LocationBlockingStrategy (start focus when at a certain location), etc.This pattern decouples how a session starts from what the session does, allowing future triggers to plug in easilymedium.com. For v1, we have basically two strategies (manual and scheduled). We’ll incorporate that concept if it doesn’t over-complicate things.* SwiftUI Best Practices:o Use @StateObject for view models in parent views so they are created once.o Use smaller, reusable views with well-defined responsibilities (e.g. a custom view for displaying a countdown timer, another for profile row UI).o Leverage SwiftUI’s environment and preference features for things like theming the app during focus (maybe a different accent color when focus is active).o Keep SwiftUI view code declarative and free of heavy logic – push that into view model or service. For example, if the user taps “End Focus”, the view just calls sessionViewModel.endSession(), and all the real work happens in the view model or manager, which then publishes changes that the view listens to (like sessionViewModel.state becomes .ended, causing navigation or UI changes).* Project Structure & Naming: We will clearly name files and types to indicate their role. For instance:o FocusKeyApp.swift – the entry point (will handle URL events and possibly set up environment objects).o FocusProfile.swift (model), FocusProfileViewModel.swift, FocusProfilesView.swift (list of profiles UI).o FocusSessionManager.swift (service).o CurrentSessionView.swift (UI shown during an active session).o SettingsView.swift (if needed for app-wide settings).o FocusKeyMonitorExtension.swift (the DeviceActivityMonitor subclass in the extension target).o We will also include any necessary Info.plist for extension with required NSExtension attributes.* Third-Party Libraries: Likely none needed besides what Apple provides (we can do everything with Apple frameworks). We might include SwiftUI Packages for things like charts if needed (SwiftCharts is built-in on iOS 16+ actually). If Supabase was used, that’s another dependency (but optional). Keeping dependencies minimal is ideal for maintenance.* Testing: This structure will make it easier to unit test the logic. For example, we can unit test FocusSessionManager’s logic by mocking out the Screen Time API calls (maybe we can’t fully simulate those, but we can structure it to allow injecting a dummy ManagedSettingsStore). At least, we can test that starting a session toggles internal flags, etc. The separation of view and logic allows headless testing of the focus logic.By following these structural guidelines, the codebase will remain clean. As one reference puts it, SwiftUI comes with MVVM built-in and it’s beneficial to decouple presentation, business logic, and data accessnalexn.github.ionalexn.github.io. FocusKey will apply these principles to ensure a robust architecture that other developers can easily navigate.Entitlements, Capabilities, and ConfigurationTo implement FocusKey’s functionality, we must configure the app with the proper entitlements and Info.plist keys, and enable specific capabilities in Xcode:* Screen Time Entitlement: As mentioned, the com.apple.developer.family-controls entitlement is required. We will add it to the app’s .entitlements file. This is a key step before running on device – without it, the Screen Time APIs will silently fail. We will request this entitlement well ahead of release and include the approval in our provisioning profiles. For TestFlight and App Store, Apple will check that our App ID has this entitlement and it has been granted by Apple (since it’s not open to all apps by default). We should be prepared to supply a demo video or explanation to Apple’s review team if they have any questions about how we use the entitlement (some apps in this category get extra scrutiny).* Associated Domains (Universal Link): To allow the NFC tag’s URL to open our app, we need to support Universal Links. In Xcode, under Signing & Capabilities, we will enable Associated Domains and add an entry of the form: applinks:focuskey.app (assuming we own focuskey.app domain, or whatever domain is chosen). This means our app is associated with that web domain. On the domain’s side, we must host an Apple App Site Association (AASA) file. This is a JSON file served at https://focuskey.app/apple-app-site-association(or under /.well-known/). The AASA file will list our app’s application identifier and the paths that should be handled as universal linksbranch.io. For example, it might contain:jsonCopyEdit{  "applinks": {    "apps": [],    "details": [      {        "appID": "<TeamID>.com.yourcompany.FocusKey",        "paths": [ "/start*", "/stop*", "/focus/*" ]      }    ]  }}This would associate URLs like https://focuskey.app/start with our app. We will ensure this file is served with the correct content type (application/json) and without an extensionbranch.io. For testing, we can use a placeholder domain or even a local AASA by editing device settings (though that’s complex – better to have a real hosted file).In the app, we will implement the handling of these links. In SwiftUI lifecycle, we can use onOpenURL or onContinueUserActivity in the App struct. For example:swiftCopyEdit@mainstruct FocusKeyApp: App {    @Environment(\.scenePhase) private var scenePhase    var body: some Scene {        WindowGroup {            ContentView()                .onOpenURL { url in                    FocusKeyURLHandler.handle(url)                }        }    }}The FocusKeyURLHandler.handle function will parse the path (/start) and perhaps a query parameter indicating which profile to start (we could encode the profile name or ID in the URL on the NFC tag). For simplicity, maybe the URL is just focuskey.app/start which always starts the default or last used profile. We might encode more info if multiple tags or modes were envisaged. The NFC card likely will be one generic trigger, so one URL is fine.* App Groups: We will add an App Group capability. For example, group.com.yourcompany.FocusKey as the identifier. This will be added to both the main app target and the DeviceActivityMonitor extension (and widget extension if present). Now both processes can access shared UserDefaults and file containers via FileManager.default.containerURL(forSecurityApplicationGroupIdentifier:). We’ll test sharing by writing a dummy value in app and reading in extension. Keep in mind to actually enable it in the provisioning as well.* NFC (if Core NFC was used): We are explicitly avoiding Core NFC for tag reading, so we do not need to include the “Near Field Communication Tag Reading” capability. If in the future we decided to support older phones by initiating a manual NFC scan, we would have to enable this capability and include NSNFCScanUsageDescription in Info.plist explaining why we scan (e.g. “Scan your FocusKey NFC card to start focus sessions”). But for now, no special NFC usage description is required for background tag reading – that uses system mechanisms. We should however include an entry in Info.plist under NSUserActivityTypes if needed (sometimes for universal links Apple recommends adding the activity type NSUserActivityTypeBrowsingWeb that we handle, but that might be automatic with associated domains).* Privacy Permissions: Apart from Screen Time (which is handled through its own prompt), our app might not need any other permissions. We’re not using camera, location, microphone, etc. If we decide to integrate notifications (for break end alerts or pre-session reminders), we will need to ask user permission for notifications. So we should include UNUserNotificationCenter requests and update Info.plist with NSUserNotificationAlertUsageDescription (although I think it’s not strictly required to have a usage description for notifications in Info.plist; Apple’s documentation says it’s not needed, you just request permission at runtime). But we’ll double-check guidelines.* Background Modes: We might consider whether to enable any Background Modes capability. Since DeviceActivityMonitor is a background extension triggered by the system, we do not need to declare a background mode for it explicitly (it’s not like background fetch or Bluetooth, it’s managed by the Screen Time system). If we want to be extra sure, we might enable the Background Processing capability to ensure the extension can run, but I believe that’s not necessary when using the Screen Time APIs – the entitlement likely covers it. We will not enable things like “Background Fetch” or “Location updates” as we don’t need them for v1. If using notifications, “Remote Notifications” background mode is not needed unless we do push, which we don’t.* Bundle Identifiers: We will have at least two targets (app and device monitor extension, plus maybe widget extension). We’ll ensure their bundle IDs are configured and added to appropriate provisioning profiles. The AASA file’s appIDs must include the TeamID prefix and the exact bundle ID of the app (and potentially we add the extension IDs under details if we wanted universal links to launch an extension, which we don’t need – only the app needs the UL).* Info.plist Configuration: We will add any usage descriptions if needed (e.g. if we use notifications: NSUserNotificationAlertUsageDescription like “FocusKey uses notifications to let you know when breaks end or focus sessions start.”). Also, for the DeviceActivityMonitor extension’s Info.plist, we need to define the extension’s principal class and possibly a deployment condition. Xcode does this if we add a new DeviceActivityMonitor target: it will put something like:xmlCopyEdit<key>NSExtension</key><dict>  <key>NSExtensionPointIdentifier</key>  <string>com.apple.deviceactivity.monitor-extension</string>  <key>NSExtensionPrincipalClass</key>  <string>$(PRODUCT_MODULE_NAME).FocusKeyMonitor</string></dict>We’ll ensure that exists so iOS knows how to run our extension. Similarly, if we add a Shield Action extension or an Activity Reporting extension in the future, those would have their own entries.* App Icon and UI Design Assets: Not exactly entitlements, but for completeness, we’ll prepare app icon, a simple launch screen, etc., aligning with the focus theme (maybe a key or target symbol). Ensure we’re not using any restricted API or private entitlements beyond family-controls.* Testing on Device: We will do extensive testing on real devices because the entitlement and NFC won’t function in the simulator. Particularly, test on an iPhone XR or later (for NFC background tag) and possibly an older device to see how it fails gracefully (the tag won’t be read in background, but maybe nothing happens, which is acceptable; we’ll include a manual start if we detect we can’t do NFC).To summarize, the main configurations are: Screen Time entitlement enabled and approvedcrunchybagel.com, Associated Domains with a proper AASA file for universal link routing, App Groups for data sharingdeveloper.apple.com, and possibly notification permissions. We will double-check all of these in the release checklist to ensure the app has the required capabilities to function as designed.Privacy and Local-Only AnalyticsFocusKey is designed with user privacy in mind, leveraging Apple’s on-device frameworks to avoid any invasive data collection. Key privacy considerations and practices include:* Sensitive Data Stays On Device: The information about which apps a user has blocked, their focus schedules, and their usage patterns is highly personal. We store this data only on the user’s device (in the App Group container) and do not transmit it to any server in v1. Even if/when we introduce optional cloud sync, it will be end-to-end encrypted or secure, and opt-in. By default, nothing leaves the device, aligning with Apple’s guidance to maintain user privacy while offering Screen Time featuresdeveloper.apple.com.* Apple’s Privacy-Preserving API: The Screen Time API itself is built to preserve privacy. For example, when the user selects apps in the FamilyActivityPicker, what we get in the app are opaque tokens, not the actual app names or IDs in plain text. We can use those tokens to configure restrictions, but we can’t (and don’t need to) derive personal information from them. Similarly, the DeviceActivity reports or events give us structured info rather than raw sensitive data. By using these APIs as intended, FocusKey avoids accessing anything beyond what’s necessary to perform blocking. We will not misuse the API to gather unrelated data (and Apple’s API doesn’t really allow it anyway – e.g., we cannot read actual screen time or websites visited except through the user’s own configuration of our app).* No Third-Party Analytics SDKs: We will not integrate third-party analytics frameworks that might track user behavior. Many apps include things like Google Analytics or Facebook SDK – FocusKey will avoid these to ensure no external party is getting data on when or how the user is focusing. If we want metrics for improving the app, we will rely on Apple’s App Analytics (aggregate, provided via App Store Connect) or implement our own extremely basic logging that does not include personal data. We can log events like “session_started” with no identifiers, just to count usage frequency, but even that will be considered carefully. Given the nature of the app, usage data is the user’s data, and we believe it should stay with them (it’s part of their habit tracking).* Local Analytics for User Benefit: As mentioned in Session Logging, we will compute things like total focus time, streaks, etc., locally and display to the user. This gives the user insight into their progress without any server. If in future we add a feature to share an achievement (like “I focused 50 hours this month!”), it will be the user’s explicit action to share, and even then, we would share only minimal data (like that statistic, not their whole log).* Privacy Policy and App Store Disclosure: We will prepare a clear privacy policy stating that:o No personal data leaves the device without user consent.o The app uses Screen Time API solely to block apps as instructed by the user.o If any cloud sync exists, what data is synced and how it’s protected.o We’ll also disclose in App Store “Data Not Collected from this app” if we truly collect nothing externally. This helps in app review as well.* Screen Time Passcode (User’s own privacy): If a user has set a Screen Time passcode (for themselves or their child), FocusKey might not function fully (because to bypass limits might require that code). We will educate the user in documentation that FocusKey is intended for use without a self-imposed passcode. If they are a parent using it to lock their kid’s device, it’s a different use-case that we aren’t focusing on (and they would use .family context not .individual). It’s worth noting: our app could technically be used by a parent on their kid’s device if they set it up under Family Sharing, but that’s beyond our current scope. In any case, FocusKey does not ask for or handle any credentials or passcodes – those remain solely in Apple’s Screen Time system. That means we never see or store the Screen Time passcode (even if one is required to override; that’s handled by iOS UI, not us).* Logging and Crash Reports: We might integrate Apple’s own analytics for crashes (e.g. the default Crashlytics or just rely on Apple’s). If we use a crash reporter like Sentry or Firebase Crashlytics, we have to ensure no sensitive info is in logs. Given our stance, we might forego those and rely on TestFlight feedback and the Apple-provided crash logs for now, to avoid any data leaving the app inadvertently.* User’s App Usage Data: FocusKey itself does not constantly monitor usage in detail – it’s mostly enforcing blocks. Apple does allow some reporting via DeviceActivity if we wanted (like we could potentially see if the user attempted to open a blocked app and count that). If we do capture such events (e.g. user tried to open Instagram 3 times during focus), we will use it only to provide feedback to the user (“You attempted 3 distractions, but stayed strong!”) if we implement that. And again, that stays local.* Beta Testing Privacy: During internal and external testing, we’ll ensure testers understand their data is local. If we use TestFlight’s feedback feature, any screenshots they send might show what apps were blocked, etc., but that’s under their control.By following these practices, we make sure FocusKey is a trusted tool for users. They can be confident that enabling FocusKey won’t result in their app usage or habits being sent to unknown servers. Apple’s frameworks plus our local-only approach mean the user’s focus data is their own. This approach not only meets legal requirements (GDPR, etc., which in this case, we’d largely be out of scope of since we’re not processing identifiable info) but also aligns with the spirit of why users would download FocusKey – to help themselves, not to have their data monetized.In terms of compliance with App Store guidelines: we will double-check Guideline 5.1 (Privacy) and ensure we have any necessary prompts (the Screen Time auth prompt covers any required consent for that domain, and we will have an in-app explanation too). Also, guideline 2.5.1 (re: using public APIs and not misuse) – using Screen Time API as intended is allowed; Apple specifically introduced it for apps like this, so we are good there. We just need to ensure we don’t use any private APIs or entitlements beyond what was granted.Testing and Acceptance CriteriaTo ensure FocusKey meets its requirements and works reliably, we will devise a comprehensive set of test cases. Below are the key test scenarios and acceptance criteria for the v1 feature set:1. Initial Authorization Prompt – Test that the app properly requests Screen Time access.Steps: Launch app fresh (or reset authorization status). Proceed through onboarding and tap the “Enable Screen Time Access” button.Expected: The system Screen Time permission dialog appears. After granting, the app recognizes the .approvedstatus (e.g. UI shows success message or moves to next setup)medium.com. If denied, the app shows a helpful error state (“Permission Denied – please enable in Settings to use FocusKey”)medium.com. The app should not crash or hang if the user dismisses the prompt without selection (treat as denied).2. FamilyActivityPicker Selection – Test selecting apps and websites to block.Steps: Navigate to create or edit a focus profile. Tap "Select Apps & Websites" to open the FamilyActivityPicker. Choose 2–3 apps, one category, and one website in the picker. Dismiss picker.Expected: The UI updates to indicate the selections (e.g. “3 Apps, 1 Category, 1 Website selected”). Internally, FamilyActivitySelection should contain those tokens. Save the profile and restart app to ensure the selection persists (loaded from storage). No sensitive app names should leak in UI – we may list them if we have a mapping, but Apple’s API might allow retrieving app names via token’s bundle ID indirectly. If we display names, ensure they match what was picked. Also check selecting "All Social" category results in that being indicated (maybe display as “Social Networking category selected”).3. Start Focus Session (Manual via NFC) – Test the core flow of locking distractions when triggered by NFC.Steps: Simulate tapping the NFC card. (For testing, we can use an actual NFC tag encoded with the URL, or simulate by manually calling the universal link on device, e.g. by Safari visiting the URL or using “Open In FocusKey” via Notes app link). The app should handle the URL event.Expected: If no session was active, the app transitions to focus mode: e.g., the focus session screen is presented (if the app was closed, it launches and perhaps directly shows a confirmation UI or the main screen changes state). The DeviceActivity monitoring starts (we verify this by attempting to open a known blocked app). All apps/websites that were configured should now be blocked:o When trying to tap a blocked app, the Screen Time shield appears, preventing launchmedium.com. For a blocked website in Safari, Safari should show a Screen Time blocked page.o Non-blocked apps continue to open normally.o The app’s UI should indicate the session is active (e.g. “Focusing...” state). Possibly a timer if configured.o If we have Live Activity enabled, check that it appears on lock screen with correct info.o No crash or error occurs when handling the URL. The app should not prompt again for permission (should reuse existing authorization).4. End Focus Session (Manual) – Test ending a session and unblocking apps.Steps: While a focus session is active (from previous test), try to end it. If using the app UI: tap “End Session” button. If using NFC toggle: tap the NFC card again (which should bring up the app and ask for confirmation, then end).Expected: The app stops DeviceActivity monitoringmedium.com and clears ManagedSettings shieldmedium.com. Verify that previously blocked apps are now immediately accessible (tap them – they should open normally again). The app UI returns to an idle or summary state (maybe showing a session summary or simply home screen). The session should be recorded in history with correct start/end times. If Live Activity was active, it should disappear or indicate ended. No Screen Time notifications remain in Notification Center about the session (the system might have left a “FocusKey started monitoring” but I think it doesn’t show anything to user aside from our UI).5. Break Request and Resume – Test the break functionality within a session.Steps: Start a focus session. After a short time, use the app’s “Take a Break” feature. For example, tap “Break 5 min”. Let the break timer run out, or manually resume early to test both flows.Expected: Upon break start, the app stops blocking apps (user can open blocked apps during break). Perhaps a countdown is visible (verify UI updates each second or so, or at least minute countdown). If the user tries to extend the break beyond allowed time, the app should prevent it (if we only allow X minutes, check that after it ends, tapping break again either doesn’t work or uses next quota). When break time is up, FocusKey should re-engage the block:o If auto-resume is implemented: verify that at the 5 min mark, the apps get blocked again automatically. This might be tricky to observe; one way is to have a blocked app open during break and see if it gets kicked out or blocked at break end. More simply, try opening a blocked app 1 minute before break ends (it opens), then try the same right after break end – it should now be blocked (maybe requiring closing and reopening if it was still in foreground, but typically if you had it open, we can’t forcibly close it; we rely on user not being actively in it, or sending a notification to say “break over, time to return to focus”).o If manual resume (user has to tap to resume): ensure the notification or prompt appears and tapping it re-blocks apps.o Check that break usage is logged (maybe in the session summary, “Break taken: 5 min”).o The break count should decrement if multiple breaks allowed. Try taking another break if quota allows, and ensure if quota is exceeded, the app disallows it (the break button could be disabled with tooltip “no breaks left”).o Ensure no crashes or lost state when toggling break on/off. Also, if break is active and user decides to fully end session, that should work (stop everything).6. Scheduled Session (Auto start/stop) – Test that scheduled focus sessions start and end at correct times.Steps: Configure a schedule for a profile (say a minute from now as start, and another minute later as end, for testing). Background the app and wait.Expected: At the scheduled start time, the DeviceActivityMonitor extension triggers and apps become blocked without user opening FocusKey manually. (We can observe by trying to open a known distracting app right after the start time – it should be blocked). Possibly the device might show a Screen Time notification that restrictions started (not sure if iOS does, but our app could optionally send one; in v1 maybe silent). The user can also open FocusKey during the session and it should recognize “Schedule X is active now”. At the scheduled end time, the restrictions lift automatically (try opening the app that was blocked – it should open fine after end time). Also verify our app logs the session in history. If we set a warningTime (if implemented), check that a notification popped up prior to start.7. Scheduled Override – Test user overriding a schedule (ending early or starting manually).Steps: While a scheduled session is active, use the app to end it early. Alternatively, before a scheduled session starts, manually trigger focus early.Expected: If ended early, the apps unblock and DeviceActivity monitoring stops for that activity. It should not immediately restart until the next scheduled cycle. (The extension might start it again next day since repeats true; that’s fine.) The history entry might note it was ended early (maybe difference between planned end vs actual end could be captured, though not essential). If started early manually, the behavior might be that schedule was due to start at 9, user started at 8:50; ideally it just runs from 8:50 – and maybe still ends at the scheduled end (if we keep schedule active). We need to ensure not to double block or conflict. A clear approach is if a manual session overlaps with a scheduled one of the same profile, treat it as one session. Our test will ensure no glitch like continuous blocking after scheduled end because manual was on – probably we’ll design it so manual start just calls the same mechanism as schedule but immediate.8. App Group Data Sharing – Test that extension and app share data properly.Steps: In the main app, set a selection of apps to block. In the extension’s code (this might require checking logs or adding a test interface), ensure it can read that selection. For example, schedule a session and have the extension apply the shield – verify it blocks the correct apps chosen in the app.Expected: The extension uses the latest selection (not an outdated one). If we update a profile’s app list, the next scheduled session uses the new list. Also, ensure the extension’s context doesn’t conflict: e.g., if we have multiple profiles, each extension event targets the correct one. This is more an integration test and can be partially covered by the scheduled session test above.9. Edge Case – No Authorization – If Screen Time authorization is denied or revoked, app behavior.Steps: Deny authorization, or revoke via iOS Settings after having granted. Then attempt to start a focus session.Expected: The app should detect a .denied or .notAuthorized status and not attempt to start monitoring (which would fail). It should prompt the user that permission is missing and direct them how to enable it (perhaps showing an alert with a button to open Settings). The app should not crash. If the user somehow tries to press start anyway, we catch the thrown error from requestAuthorization or from startMonitoring and handle gracefully (maybe show an error message “Unable to start focus – permission not granted”).10. Edge Case – Entitlement Missing (Dev Testing) – If the app is run without the entitlement (say on a simulator or a developer forgot to apply), ensure it fails gracefully.Steps: (This is mostly a developer test) Run on a device that doesn’t have the entitlement in the provisioning profile.Expected: AuthorizationCenter.requestAuthorization likely immediately throws an error. Our code should catch and print/log “Failed to request authorization: ...”medium.com instead of crashing. We likely will never ship without entitlement, but during development, this helps identify the issue.11. NFC Tag/Universal Link Behavior – Test the NFC trigger end-to-end.Steps: With a physical NFC tag encoded to our URL, ensure the device (iPhone Xs or later) reacts properly:o When phone screen is on and unlocked, tapping tag shows a banner “Open in FocusKey?”. Tapping it opens our app.o When phone is locked (but was unlocked at least once after reboot), tapping tag wakes screen and shows the same prompt (after unlock, it continues).o When phone screen is off entirely, tapping might not do anything until screen on (expected hardware behavior).Expected: In all cases, the universal link successfully routes to FocusKey. There should be no scenario where Safari opens our domain instead. If Safari opens, it means AASA or associated domain config failed (so that’s a fail criteria – must fix config). We’ll test on both a device with FocusKey installed (should open app) and not installed (should go to our website if we have one or do nothing; since if not installed and we have a site, maybe we show a landing page “Please install FocusKey”). The acceptance is that the NFC integration works seamlessly for supported iPhones.12. UI/UX Checks:o Focus Mode UI clarity: When active, the UI should clearly show the user is in focus mode (distinct from normal state). Test that labels, icons (maybe a “lock” icon or different theme color) appear correctly.o Timer accuracy: If a countdown is shown, test that it runs correctly (e.g., a 25-min session actually ends at 25 min, not off by a minute). This might require simulating time or trusting system scheduling.o Responsive design: Test UI on different screen sizes (iPhone SE, iPhone 14 Pro Max). Ensure layout for the focus session screen and pickers are not broken. Also test dark mode vs light mode.o Localization (if any): If we plan to support multiple languages in future, not in v1 likely, but ensure at least nothing is hard-coded that can’t be localized.13. Performance and Battery:o Start a very long session and monitor battery usage. The DeviceActivity/ManagedSettings approach should be very light on battery (just OS enforcing rules). Our app can actually be closed and it still works. But if we keep a Live Activity updating every second, we should ensure that doesn’t drain too much battery. Check memory usage for leaks (start/end sessions repeatedly and see memory profile).o The app should not overly wake up in background except when needed.14. TestFlight Reviewer Scenario:o Provide a scenario for TestFlight/Apple review team: e.g., ensure the app doesn’t crash if no NFC (like iPad). If installed on an iPad (which has no NFC reader), we should hide or disable the “use NFC” wording and allow manual start. We test FocusKey on an iPad to ensure it handles lack of NFC gracefully (capability check for CoreNFC not needed, but we know background NFC won’t work on iPad). The focus blocking on iPad should still function if manually triggered.o Also test on iOS 16 if we support minimum iOS 16 (with SwiftUI we likely require iOS 17 because of SwiftData maybe, but if we choose to support 16 for more devices, we ensure code paths still work. FamilyControls API was introduced in iOS 15/16 so should be present).The above test cases will be documented and each marked pass/fail during QA. Acceptance Criteria for release: All major use cases (authorization, start/stop, break, schedule) must work consistently without crashes or unintended unblocking, on at least the latest iOS (17) and preferably one version back if supported. The Screen Time restrictions must reliably prevent access to specified apps during focus (this is the core promise of the app) – a session is only considered successful if the blocked apps truly cannot be opened. Also, the NFC trigger must reliably invoke the app, as that is a key user experience element.We’ll also test some malicious scenarios like trying to uninstall the app during a focus session (likely iOS would end restrictions automatically if the app that set them is gone, but we can try if allowed, or the user might not be able to delete an app while its restrictions active – we should see). Not critical but good to know behavior.QA and Release ChecklistBefore releasing FocusKey (whether to internal testers or App Store), we will go through a thorough QA and release readiness checklist:* Entitlement Verification:o  Family Controls Entitlement granted: Confirm that Apple has approved the entitlement for the app’s bundle ID. Double-check the provisioning profile in Xcode shows com.apple.developer.family-controls= YES. Build and run on a device to ensure AuthorizationCenter.shared.authorizationStatus reports .approved after user consent (indicating entitlement + user permission are working).o  All Targets have Entitlement: Ensure any extension (DeviceActivityMonitor, Widget) also includes the entitlement in its entitlements filemedium.com. Test that the extension can run (extension will not load if entitlement missing, possibly causing silent failure to enforce schedule).* Associated Domains & NFC:o  AASA File deployed: Verify the apple-app-site-association file is accessible via HTTPS on the expected domain. Use curl -I https://focuskey.app/apple-app-site-association to ensure a 200 OK and correct content type. Optionally, use Apple’s AASA validator or the apsctl tool to test it.o  Associated Domains capability: Ensure the app’s Associated Domains in the build match the domain where AASA is hosted (no typos like missing www if needed, etc.).o  NFC Tag programmed correctly: Program the NFC card with the exact URL (and ensure it’s an NDEF with proper URI record). Test the physical tag with a device as described in testing.o  Universal Link routing: On a device with the app installed, tapping the NFC (or opening the link from another app) should directly open FocusKey without going to Safari. On a device without app, tapping tag should prompt to open in Safari (if we have a site, or just do nothing if no site – that’s fine).o  No Core NFC usage: Confirm we didn’t accidentally include CoreNFC frameworks or code that might trigger an NFC usage permission. Our design doesn’t require it, so the app should not request NFC permission at any point.* Functionality QA Pass:o  Basic flows tested: All the test cases in the previous section are executed on at least one physical device and passed. Any critical bug found is fixed. In particular, test on an iPhone running the target iOS version (17) and possibly one on iOS 16 if supported to catch any compatibility issues with Screen Time API changes (the API had updates in iOS 16, so we ensure .individual usage works on 16 too since it was introduced thencrunchybagel.com).o  Edge cases: Try unusual sequences: e.g., start a session, reboot the phone in middle – check after reboot if restrictions are still applied (they might be until DeviceActivity says interval ended, which could be weird if schedule was on; likely reboot clears it, but we should see). Ensure no data corruption if phone dies during a session.o  No leftover shields: After session end, confirm ManagedSettings shields are nil. (We can even write a debug function to print store.shield settings to ensure they’re cleared, or check in Settings > Screen Time > App Limits to see none remain if any appear there).o  UI/UX polish: All UI text, buttons, icons are final. Check spelling, alignment, dark mode. Verify the app icon is set and looks good on device. The onboarding text clearly explains any permission. The focus session screen clearly instructs how to end or break.o  Performance: Run a long focus session and observe CPU usage via Xcode Instruments if possible; it should be minimal when idle. The Live Activity (if on) updates at reasonable intervals (we might update every minute rather than every second to save battery, unless second-by-second is needed for short breaks).o  Memory: Check for any leaks (using Instruments Leaks template after starting/stopping sessions repeatedly). Also ensure we’re not holding onto any sensitive objects in memory unnecessarily (like we’re not leaking the FamilyActivitySelection beyond needed, though that’s not sensitive per se).* App Store Metadata and Settings:o  App ID configuration: The App ID on Apple Developer portal has the Associated Domain and any other capabilities enabled (like iCloud if used, etc.). The profiles are updated to match.o  App Privacy Survey: In App Store Connect, fill out the privacy questionnaire. Likely we will answer that we do not collect any data. (Using Screen Time API might require classifying it, but since data is on-device, it’s not “collected”). Ensure it reflects our actual practices to avoid App Store rejection.o  Descriptions and Keywords: Prepare the App Store description to accurately represent the app (especially highlight requiring Screen Time permission and works entirely on-device). Also mention the need for devices with NFC for the tap feature (so users with older iPhones aren’t confused – maybe we explicitly say requires iPhone Xs or later for tap feature, though the app can still be used manually on older phones).o  Screenshots: Capture screenshots of the app in action (maybe staged: one showing the profiles selection, one showing the focus active timer screen, one maybe showing a Live Activity on lock screen, etc.). Possibly also screenshot of the FamilyActivityPicker (though that’s an Apple UI, but it might be allowed in screenshots to show how user picks apps). Ensure no sensitive content is shown in screenshots – since in testing we might pick random apps, for App Store, perhaps pick generic non-branded app icons to avoid any trademark issues or just mention “Social App” etc. Apple sometimes rejects screenshots showing other app icons; but since our app literally deals with other apps, we might show a partial blurred home screen or just the act of blocking. We’ll be cautious here.o  Beta Testing plan: For internal testers or TestFlight external testers, provide instructions because this app has special setup:* E.g. instruct testers how to grant Screen Time permission (Settings > Screen Time > [App Name] if they skipped initial prompt).* Provide them an NFC tag if possible or instruct them how to simulate by tapping a link. Perhaps have a mode in-app to simulate NFC trigger (a debug button “Start Focus”).* Have them test blocking a set of dummy apps. Possibly ensure testers have at least one common app to try blocking (like YouTube) to verify it’s blocked.* Collect feedback on any confusion or issues.* App Review Preparation:o  Write App Review Notes to submit with the binary. Explain the use of the Screen Time API and entitlement: For example, “FocusKey uses Apple’s Screen Time APIs (with FamilyControls entitlement) to block apps as requested by the user. The NFC integration uses universal links to trigger the focus mode. No user data is uploaded to any server.” This pre-empts any questions from the review team.o  If any special configuration needed for the reviewer: Possibly provide a test account for any cloud (if we had one; not in v1). Or if the app needs the NFC card, perhaps mention that it can be tested by tapping the URL in Safari as an alternative trigger since the reviewer might not have our physical card. We could also ship a TestFlight build where NFC is not required (like a button to start focus) to make their life easier. Or mention in notes: “If you do not have the NFC card, you can trigger focus by doing XYZ (like long-press app icon -> Start Focus if we add quick action, or simply by opening the app and tapping Start).”* Compliance and Guidelines:o  Ensure that we are not violating any Apple guidelines. Specifically check Guideline 2.5.4 (if using background refresh appropriately – in our case it’s system scheduled so okay), Guideline 5.1 (privacy) – we’ve addressed that, Guideline 4.5 (VPN/MDM – we are not using those, just Screen Time which is allowed for this purpose). Parental control apps sometimes face extra scrutiny but ours is self-help, which should be fine as many such apps exist (Opal, Freedom, etc.). We just must ensure we don’t use any private API or do anything like disabling other app functions beyond Screen Time API.o  Trademark/IP: We should not mention specific app names in our App Store description like “blocks Facebook, Instagram” explicitly – that might be okay, but to be safe we might say “blocks social media apps, video apps, etc.” Similarly, ensure our name and branding don’t conflict with another (FocusKey seems unique). We have to avoid using the word “Screen Time” in a misleading way (we can mention uses Screen Time API, but not to confuse with Apple’s Screen Time feature itself – though in context it should be fine).* Deployment:o  Build in Release mode and run tests on device one more time. Sometimes debug vs release can have slight differences. Particularly test that everything works in a release signed build (especially entitlement).o  Submit to TestFlight for external testing once internal QA is satisfied. Use that as a “dress rehearsal” for App Store release. External testers might catch things we didn’t.o  Monitor Logs: While testers use the app, monitor the Console logs for any Screen Time API errors or exceptions. Also, have them check in Settings > Screen Time > FocusKey (if it appears) – maybe to verify the authorization status.* User Documentation:o  Prepare a short in-app help or FAQ. Possibly an onboarding that can be revisited. Cover questions like “What if I need to urgently use a blocked app?” (Answer: you can end focus anytime – FocusKey is voluntary). “Why does FocusKey need Screen Time permission?” (Answer: It uses Apple’s API to block apps you choosecrunchybagel.com). “My NFC doesn’t work” (Answer: ensure device supports background NFC or use manual start).o This isn’t required for release but improves user satisfaction.Once all checklist items are done and all tests are passing, we’ll be confident to release FocusKey v1. The result will be a robust, production-ready app that helps users stay focused by seamlessly integrating with iOS’s Screen Time capabilities, triggered by a simple tap of a card – all implemented with careful attention to architecture, privacy, and quality.